import {
    BlockingReasonCounter, NotNumberedZone, Row, Seat, SeatStatus, Sector, StatusCounter, VenueMap, VenueTemplateItem, VenueTemplateItemType
} from '@admin-clients/shared/venues/data-access/standard-venue-tpls';
import { formatNumber } from '@angular/common';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { getNNZIdentifierFunction, getSeatIdentifierFunction } from '../../utils/venue-item-managing-functions.utils';
import { VenueTemplateLabel, VenueTemplateLabelGroup } from '../label-group/venue-template-label-group-list.model';
import { VenueTemplateLabelGroupType } from '../label-group/venue-template-label-group-type.enum';
import { VenueTemplateItemWrapperDataModel } from './venue-template-item-wrapper-data.model';

export class VenueTemplateItemWrapper {
    private readonly _crossData: VenueTemplateItemWrapperDataModel;
    item: VenueTemplateItem;
    label: string;
    level: number;
    hasChildren: boolean;
    showHoverEffect: boolean;
    selectable: boolean;
    selected: boolean;
    partiallySelected: boolean;
    totalSeats: number;
    freeSeats: number;
    hasAnyButton: boolean;
    editButton: boolean;
    cloneButton: boolean;
    deleteButton: boolean;
    isAisle: boolean;
    updateItemData: () => void;
    statusInfo: { icon: SafeHtml; color: string };
    vtLabelColorNNZ: string[];
    vtLabelLabelNNZ: string[];
    vtLabelLabelNNZTooltip: string;
    vtLabelColorSeat: string;
    vtLabelLabelSeat: string;
    children: VenueTemplateItemWrapper[];
    hidden?: boolean;
    filtered: boolean;
    elementId: string; // for qa purposes

    constructor(item: VenueTemplateItem, crossData: VenueTemplateItemWrapperDataModel) {
        this.item = item;
        this._crossData = crossData;
        switch (item.itemType) {
            case VenueTemplateItemType.sector:
                this.parseSector(item);
                break;
            case VenueTemplateItemType.notNumberedZone:
                this.parseNotNumberedZone(item);
                break;
            case VenueTemplateItemType.notNumberedZoneStatusCounter:
                this.parseStatusCounter(item);
                break;
            case VenueTemplateItemType.notNumberedZoneBlockingReasonCounter:
                this.parseBlockingReasonCounter();
                break;
            case VenueTemplateItemType.row:
                this.parseRow(item);
                break;
            case VenueTemplateItemType.aisle:
                this.parseAisle();
                break;
            case VenueTemplateItemType.seat:
                this.parseSeat(item);
                break;
        }
        // any problem generated by item data in this line, is generated by an item bad generation or format issue,
        // search for any new item instantiation, maybe a lack of itemType?
        this.updateItemData();
    }

    static parseVenueMap(venueMap: VenueMap, crossData: VenueTemplateItemWrapperDataModel): VenueTemplateItemWrapper[] {
        return venueMap?.sectors.map(sector => new VenueTemplateItemWrapper(sector, crossData)) || [];
    }

    static updateItems(items: VenueTemplateItemWrapper[], types: VenueTemplateItemType[] = null): void {
        if (items) {
            let typesSet: Set<VenueTemplateItemType>;
            if (types) {
                typesSet = new Set<VenueTemplateItemType>();
                types.forEach(type => typesSet.add(type));
            }
            items.forEach(item => VenueTemplateItemWrapper.updateItemData(item, typesSet));
        }
    }

    static indexStateLabelGroup(
        crossData: VenueTemplateItemWrapperDataModel,
        labelGroups: VenueTemplateLabelGroup[],
        sanitizer: DomSanitizer
    ): void {
        if (crossData) {
            const statusLabelsMap = new Map<SeatStatus, { color: string; icon: SafeHtml }>();
            if (labelGroups) {
                const stateLabelGroup = labelGroups.find(labelGroup => labelGroup.id === VenueTemplateLabelGroupType.state);
                if (stateLabelGroup) {
                    stateLabelGroup.labels.forEach(label => {
                        statusLabelsMap.set(label.id as SeatStatus,
                            {
                                color: label.color,
                                icon: sanitizer.bypassSecurityTrustHtml(label.icon)
                            }
                        );
                    });
                }
            }
            crossData.statusLabelsMap = statusLabelsMap;
        }
    }

    static indexBlockingReasons(
        crossData: VenueTemplateItemWrapperDataModel,
        labelGroups: VenueTemplateLabelGroup[]
    ): void {
        if (crossData) {
            const blockingReasonsMap = new Map<string, VenueTemplateLabel>();
            if (labelGroups) {
                const blockingReasonsGroup
                    = labelGroups.find(labelGroup => labelGroup.id === VenueTemplateLabelGroupType.blockingReason);
                if (blockingReasonsGroup?.labels) {
                    blockingReasonsGroup.labels.forEach(label => blockingReasonsMap.set(label.id, label));
                }
            }
            crossData.blockingReasonsMap = blockingReasonsMap;
        }
    }

    static indexSelectedLabelGroup(
        crossData: VenueTemplateItemWrapperDataModel,
        selectedLabelGroup: VenueTemplateLabelGroup
    ): void {
        crossData.selectedLabelGroup = selectedLabelGroup;
        crossData.seatIdentifierFunction = null;
        crossData.nnzIdentifierFunction = null;
        crossData.selectedLabelGroupLabels = null;
        if (selectedLabelGroup) {
            crossData.seatIdentifierFunction = getSeatIdentifierFunction(selectedLabelGroup.id);
            crossData.nnzIdentifierFunction = getNNZIdentifierFunction(selectedLabelGroup.id);
            const labelMap = new Map<string, VenueTemplateLabel>();
            selectedLabelGroup.labels?.forEach(label => labelMap.set(label.id, label));
            labelMap.set('-1', null);
            crossData.selectedLabelGroupLabels = labelMap;
        }
    }

    private static updateItemData(item: VenueTemplateItemWrapper, types: Set<VenueTemplateItemType>): void {
        if (!types?.size || types.has(item.item.itemType)) {
            item.updateItemData();
        }
        if (item.children) {
            item.children.forEach(innerItem => VenueTemplateItemWrapper.updateItemData(innerItem, types));
        }
    }

    // sector

    private parseSector(sector: Sector): void {
        this.elementId = `${sector.itemType}-${sector.id}`;
        this.label = sector.name;
        this.children = [];
        if (sector.rows && sector.rows.length > 0) {
            this.children.push(...sector
                .rows
                .sort((a, b) => a.order - b.order)
                .map(row => new VenueTemplateItemWrapper(row, this._crossData)));
        }
        if (sector.notNumberedZones && sector.notNumberedZones.length > 0) {
            this.children.push(...sector.notNumberedZones.map(zone => new VenueTemplateItemWrapper(zone, this._crossData)));
        }
        this.hasChildren = this.children.length > 0;
        this.level = 0;
        this.totalSeats = this.getSectorTotalSeats(sector);
        this.editButton = this._crossData.canEditSectors;
        this.cloneButton = this._crossData.canCloneSectors;
        this.deleteButton = sector.record?.pendingToCreate || this._crossData.canDeleteSectors;
        this.selectable = true;
        this.showHoverEffect = true;
        this.hasAnyButton = true;
        this.updateItemData = this.updateSectorData.bind(this);
    }

    private updateSectorData(): void {
        const sector = this.item as Sector;
        this.label = sector.name;
        this.freeSeats = this.getSectorFreeSeats(sector);
        const visibleChildren = this.children.filter(child => !child.hidden);
        this.selected = visibleChildren.length > 0 && visibleChildren.every(child => child.selected);
        this.partiallySelected = !this.selected && this.children.some(child => child.selected || child.partiallySelected);
    }

    // row

    private parseRow(row: Row): void {
        this.elementId = `${row.itemType}-${row.id}`;
        this.label = row.name;
        this.hasChildren = true;
        this.level = 1;
        this.totalSeats = row.seats.length;
        this.freeSeats = this.getRowFreeSeats(row);
        this.selectable = true;
        this.showHoverEffect = true;
        this.children = [];
        if (row.seats && row.seats.length > 0) {
            let lastRowBlock = null as string;
            row.seats
                .sort((a, b) => a.order - b.order)
                .forEach(seat => {
                    if (lastRowBlock !== null && lastRowBlock !== seat.rowBlock) {
                        this.children.push(new VenueTemplateItemWrapper({ itemType: VenueTemplateItemType.aisle }, this._crossData));
                    }
                    lastRowBlock = seat.rowBlock;
                    this.children.push(new VenueTemplateItemWrapper(seat, this._crossData));
                });
        }
        this.updateItemData = this.updateRowData.bind(this);
    }

    private updateRowData(): void {
        const row = this.item as Row;
        this.freeSeats = this.getRowFreeSeats(row);
        const visibleChildSeats = this.children.filter(child => child.item.itemType === VenueTemplateItemType.seat && !child.hidden);
        this.selected = visibleChildSeats.length > 0 && visibleChildSeats.every(child => child.selected);
        this.partiallySelected = !this.selected && this.children.some(child => child.selected);
    }

    // isAisle

    private parseAisle(): void {
        this.isAisle = true;
        this.level = 2;
        this.updateItemData = this.updateAisle.bind(this);
    }

    private updateAisle(): void {
        // aisles doesn't require any update, but to skip function presence, there's an empty function
    }

    // seat

    private parseSeat(seat: Seat): void {
        this.elementId = `${seat.itemType}-${seat.id}`;
        this.label = seat.name;
        this.selectable = true;
        this.level = 2;
        this.updateItemData = this.updateSeatData.bind(this);
    }

    private updateSeatData(): void {
        const seat = this.item as Seat;
        if (this._crossData.statusLabelsMap) {
            this.statusInfo = this._crossData.statusLabelsMap.get(seat.status);
        }
        let vtLabel: VenueTemplateLabel;
        if (this._crossData.selectedLabelGroup && this._crossData.selectedLabelGroup.id !== VenueTemplateLabelGroupType.state) {
            vtLabel = this._crossData.selectedLabelGroupLabels.get(this._crossData.seatIdentifierFunction(seat));
        }
        if (vtLabel) {
            this.vtLabelLabelSeat = vtLabel.literal;
            this.vtLabelColorSeat = vtLabel.color;
        }
        if (this._crossData.selectedSeats) {
            this.selected = this._crossData.selectedSeats.has(seat.id);
        }
    }

    // not numbered zones

    private parseNotNumberedZone(zone: NotNumberedZone): void {
        this.elementId = `${zone.itemType}-${zone.id}`;
        this.level = 1;
        this.label = zone.name;
        this.selectable = true;
        this.showHoverEffect = true;
        this.hasAnyButton = true;
        this.editButton = this._crossData.canEditNNZ;
        this.cloneButton = this._crossData.canCloneNNZ;
        this.deleteButton = zone.record?.pendingToCreate || this._crossData.canDeleteNNZ;
        this.updateItemData = this.updateNotNumberedZoneData.bind(this);
    }

    private updateNotNumberedZoneData(): void {
        const zone = this.item as NotNumberedZone;
        this.label = zone.name;
        this.totalSeats = zone.capacity;
        this.freeSeats = this.getNNZFreeSeats(zone);
        this.hasChildren = zone.statusCounters.length > 1 || (zone.blockingReasonCounters && zone.blockingReasonCounters.length > 1);

        this.updateNotNumberedChildren(zone);
        this.updateNotNumberedZoneLabels(zone);

        if (this._crossData.selectedZones) {
            this.selected = this._crossData.selectedZones.has(zone.id);
        }
    }

    private updateNotNumberedChildren(zone: NotNumberedZone): void {
        if (!this.hasChildren) {
            if (this._crossData.statusLabelsMap && zone.statusCounters?.length) {
                this.statusInfo = this._crossData.statusLabelsMap.get(zone.statusCounters[0].status);
            }
        } else {
            this.children = this.children || [];
            const resultChildren: VenueTemplateItemWrapper[] = [];
            zone.statusCounters.forEach(statusCounter => {
                if (statusCounter.status !== SeatStatus.promotorLocked) {
                    let statusCounterWrapper
                        = this.children.filter(w => w.item.itemType === VenueTemplateItemType.notNumberedZoneStatusCounter)
                        .find(w => (w.item as StatusCounter).status === statusCounter.status);
                    if (!statusCounterWrapper) {
                        statusCounterWrapper = new VenueTemplateItemWrapper(statusCounter, this._crossData);
                    }
                    resultChildren.push(statusCounterWrapper);
                }
            });
            if (zone.blockingReasonCounters) {
                zone.blockingReasonCounters.forEach(blockingReasonCounter => {
                    let brCounterWrapper
                        = this.children.filter(w => w.item.itemType === VenueTemplateItemType.notNumberedZoneBlockingReasonCounter)
                        .find(w => (w.item as BlockingReasonCounter).blocking_reason === blockingReasonCounter.blocking_reason);
                    if (!brCounterWrapper) {
                        brCounterWrapper = new VenueTemplateItemWrapper(blockingReasonCounter, this._crossData);
                    }
                    resultChildren.push(brCounterWrapper);
                });
            }
            this.children = resultChildren;
        }
    }

    private updateNotNumberedZoneLabels(zone: NotNumberedZone): void {
        this.vtLabelLabelNNZTooltip = null;
        this.vtLabelLabelNNZ = [];
        this.vtLabelColorNNZ = [];
        if (
            this._crossData.selectedLabelGroup
            && this._crossData.selectedLabelGroup.id !== VenueTemplateLabelGroupType.state
            && (this._crossData.selectedLabelGroup.id !== VenueTemplateLabelGroupType.blockingReason || !this.hasChildren)
        ) {
            if (
                this._crossData.selectedLabelGroup.nnzPartialApply &&
                this._crossData.selectedLabelGroup.id === VenueTemplateLabelGroupType.quota
            ) {
                zone.quotaCounters.forEach(quotaCounter => {
                    const foundLabel = this._crossData.selectedLabelGroup.labels
                        .find(label => label.id === quotaCounter.quota.toString());
                    if (foundLabel) {
                        this.vtLabelLabelNNZ.push(this.getNNZCounterLine(foundLabel.literal, quotaCounter.count));
                        this.vtLabelColorNNZ.push(foundLabel.color);
                    }
                });
                if (this.vtLabelLabelNNZ.length > 1) {
                    this.vtLabelLabelNNZTooltip = this.vtLabelLabelNNZ.join('\n');
                }
            } else {
                const vtLabel = this._crossData.selectedLabelGroupLabels.get(this._crossData.nnzIdentifierFunction(zone));
                if (vtLabel) {
                    this.vtLabelLabelNNZ = [vtLabel.literal];
                    this.vtLabelColorNNZ = [vtLabel.color];
                }
            }
        }
    }

    private getNNZCounterLine(literal: string, count: number): string {
        return `${literal}: ${this.formatNum(count)}`;
    }

    private formatNum(value: number): string {
        return formatNumber(value, this._crossData.locale, '.0-2');
    }

    private parseStatusCounter(statusCounter: StatusCounter): void {
        this.level = 2;
        this.label = 'ENUMS.SEAT_STATUS_PLURAL.' + statusCounter.status;
        this.updateItemData = this.updateStatusCounter.bind(this);
    }

    private updateStatusCounter(): void {
        const statusCounter = this.item as StatusCounter;
        this.totalSeats = statusCounter.count;
        if (this._crossData.statusLabelsMap) {
            this.statusInfo = this._crossData.statusLabelsMap.get(statusCounter.status);
        }
    }

    private parseBlockingReasonCounter(): void {
        this.level = 2;
        this.updateItemData = this.updateBlockingReasonCounter.bind(this);
    }

    private updateBlockingReasonCounter(): void {
        const blockingReasonCounter = this.item as BlockingReasonCounter;
        if (this._crossData.statusLabelsMap) {
            this.statusInfo = this._crossData.statusLabelsMap.get(SeatStatus.promotorLocked);
        }
        if (this._crossData.blockingReasonsMap && this._crossData.blockingReasonsMap.size > 0) {
            const blockingReasonLabel = this._crossData.blockingReasonsMap.get(blockingReasonCounter.blocking_reason.toString());
            this.label = blockingReasonLabel?.literal;
        }
        this.totalSeats = blockingReasonCounter.count;
    }

    // count functions

    private getSectorTotalSeats(sector: Sector): number {
        let totalSeats = 0;
        if (sector.rows) {
            sector.rows.forEach(r => totalSeats += r.seats.length);
        }
        if (sector.notNumberedZones) {
            sector.notNumberedZones.forEach(n => totalSeats += n.capacity);
        }
        return totalSeats;
    }

    private getSectorFreeSeats(sector: Sector): number {
        let result = 0;
        if (sector.rows) {
            sector.rows.forEach(row => result += this.getRowFreeSeats(row));
        }
        if (sector.notNumberedZones) {
            sector.notNumberedZones.forEach(nnz => result += this.getNNZFreeSeats(nnz));
        }
        return result;
    }

    private getNNZFreeSeats(nnz: NotNumberedZone): number {
        return (nnz.statusCounters.find(sc => sc.status === SeatStatus.free) || { count: 0 }).count;
    }

    private getRowFreeSeats(row: Row): number {
        return row.seats.filter(seat => seat.status === SeatStatus.free).length;
    }
}
